module binaryimageanalyzer;

import std.algorithm;
import std.array;
import std.conv;
import std.file;
import std.getopt;
import std.algorithm.iteration;
import std.math;
import std.stdio;
import std.string;
import std.traits;

ubyte[T.sizeof] toUBytes(T)(T data)
	if (isIntegral!T || isFloatingPoint!T)
{
	union conv
	{
		T type;
		ubyte[T.sizeof] b;
	}
	conv tb = { type : data };
	return tb.b;
}

enum RecordType : ubyte
{
	Header = 0,
	Data16bit,
	Data24bit,
	Data32bit,
	Count16bit = 5,
	Count24bit,
	StartAddr32bit,
	StartAddr24bit,
	StartAddr16bit
}

struct Record
{
	RecordType type;
	ubyte recordLength;
	uint address;
	ubyte[] data;
	ubyte checksum;
}

ubyte[] toUbytes(string dataStr, ref uint offset)
{
	ubyte[] arr = new ubyte[(dataStr.length - offset)/2];

	foreach(ref el; arr)
	{
		string str = dataStr[offset..offset+2];

		offset += 2;
		el = str.parse!ubyte(16U);
	}

	return arr;
}

Record parseRecord(string recordStr)
{
	Record record;
	RecordType recType;
	int addrSize;
	uint offset = 1;

	switch(recordStr[offset])
	{
		case '0':
			record.type = RecordType.Header;
			addrSize = 2;
			break;
		case '1':
			record.type = RecordType.Data16bit;
			addrSize = 2;
			break;
		case '2':
			record.type = RecordType.Data24bit;
			addrSize = 3;
			break;
		case '3':
			record.type = RecordType.Data32bit;
			addrSize = 4;
			break;
		case '5':
			record.type = RecordType.Count16bit;
			break;
		case '6':
			record.type = RecordType.Count24bit;
			break;
		case '7':
			record.type = RecordType.StartAddr32bit;
			addrSize = 4;
			break;
		case '8':
			record.type = RecordType.StartAddr24bit;
			addrSize = 3;
			break;
		case '9':
			record.type = RecordType.StartAddr16bit;
			addrSize = 2;
			break;
		default:
			break;
	}
	offset++;

	string recLen = recordStr[offset..offset+2];
	//("recLen: "~recLen.to!string).writeln;

	record.recordLength = recLen.parse!ubyte(16U);
	offset += 2;

	string addrStr = recordStr[offset..offset+addrSize*2];
	//("addrStr: "~addrStr.to!string).writeln;

	record.address = addrStr.parse!uint(16U);
	offset += addrSize*2;

/+
	("offset: "~offset.to!string).writeln;
	("recordStr: "~recordStr).writeln;
	("recordStr.length: "~recordStr.length.to!string).writeln;
+/
	record.data = recordStr[0..$-2].toUbytes(offset);

	return record;
}

void main(string[] args)
{
	string addressStr, sizeStr;
	string fileName;
	bool generate;


	getopt(args, "file", &fileName, "gen", &generate, "address", &addressStr, "size", &sizeStr);

	if(fileName == "")
	{
		writeln("no input file, exiting");
		return;
	}

	if(!generate)
	{
		if(!exists(fileName))
		{
			writeln("file ", fileName, " does not exist. Exiting");
			return;
		}

		writeln("Analyzing ", fileName);

		string file = to!string(read(fileName));

		string[] textRecords = file.splitLines;

		Record[] records = new Record[textRecords.length];

		foreach(int i, immutable record; textRecords)
		{
			records[i] = record.parseRecord;
		}

		foreach(record; records)
		{
			string dataStr;
			foreach(immutable el; record.data)
			{
				dataStr ~= toChars!(16, char, LetterCase.upper)(cast(immutable uint)el).array.rightJustify(2, '0') ~ " ";
			}

			if(record.type == RecordType.Header)
			{
				writeln("header: ", cast(char[])record.data);
			}
			else
			{
				writeln(record.recordLength.to!string, "\t0x", record.address.toChars!(16, char, LetterCase.upper), "\t", dataStr);
			}
		}
	}
	else
	{
		ubyte[] data = new ubyte[ushort.max];
		string output;

		foreach(uint i, ref el; data)
		{
			el = cast(ubyte)i;
		}

		uint address = 0xFE8000;
		uint bytesPerRecord = 32;
		uint imageSize = 0x10000;
		
		if(addressStr != "")
		{
			if(addressStr.canFind("0x"))
			{
				string tmp = addressStr[2..$];
				address = tmp.parse!uint(16);
			}
			else
			{
				address = addressStr.parse!uint;
			}
		}
		if(sizeStr != "")
		{
			if(sizeStr.canFind("0x"))
			{
				string tmp = sizeStr[2..$];
				imageSize = tmp.parse!uint(16);
			}
			else
			{
				imageSize = sizeStr.parse!uint;
			}
		}
		
		writeln("address is: ", address);

		uint numRecords = to!uint(ceil(cast(double)imageSize/cast(double)bytesPerRecord));
		uint offset = 0;


		string headerInfo = "Test image generated by BinaryImageAnalyzer: "~fileName;
		//char[] bytes = 
		output = "S0030000FC\n";

		foreach(int i; 0..numRecords-1)
		{
			uint[36] tmpData;
			tmpData[0] = 36;
			auto addr = toUBytes(address)[0..$-1];
			reverse(addr);
			tmpData[1..4] = to!(uint[])(addr);
			tmpData[4..$] = to!(uint[])(data[offset..offset+32]);
			offset += 32;

			uint checksum = 0;
			string rec = `S2`;

			foreach(el; tmpData)
			{
				checksum += el;
				rec ~= toChars!(16, char, LetterCase.upper)(el).array.rightJustify(2,'0');
			}

			checksum &= 0xFF;		
			checksum = (~checksum) & 0xFF;
			
			rec ~= toChars!(16, char, LetterCase.upper)(checksum).array.rightJustify(2,'0');

			output ~= rec~'\n';
			address += 32;
		}

		std.file.write(fileName, output);
	}
}
